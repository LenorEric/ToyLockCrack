# 补充说明

Lenor

## 表是怎么打出来的

现在已经知道了这样一些东西：

* 对于一个内容全部一样的序列（比如都是1），它内部元素也是有差别的
* 同一个明文 a，在同样的位置出现在不同类的组里（就是相同密文不同校验位），它的结果也不同
* 处理时是 321321 分组来的
* 同一个组、同一个位置、同样的明文，加密后密文相同（可以通过大数实验证明）

不难看出，密文和 明文x、位置t、校验位位置 n 有关。即 e = encrypt(x,t,n) 。考虑到逆元性质，encrypt 函数大概率为和函数。这里可以采用分离变量法，将其看成三个的（和）正交的函数之和，其中，x和 t、n 严格正交，t和n 可以构建出正交的数据。（懂意思就行，和正交是啥不用太在意）

因此先考虑明文：

```
000000000000000000000000000000000000000000000
```

密文是：

n=0: 047068603624269280825846481402  047068603624257

n=1: 153501719167375723931389597945  153501719167375

可以看出是有一个循环节的，循环节长度为 30 = 5 * 6 = 5 * (3+2+1)。

此外，对其分组得

0 470 68 6 036 24 2 692 80 8 258 46 4 814 02  0 47068603624257

15 3 501 71 9 167 37 5 723 93 1 389 59 7 945  15 3 501719167375

那么为什么循环节是 30 呢？

不难看出，30 = LCM(10, 6) = LCM(5, 6)

现在明文每一位相同，因此密文仅和 当前位数、组的种类 有关。6 肯定是组的种类，那么 10 或 5 就是位数带来的影响了。

总的来说，是 10 的概率更大一些。

因此假设 encrypt_xn(t) = t % 10 + c

接下来是 猜测 encrypt_nt(x)。由于最后叠加的时候常数 c 会一起叠加，所以不再考虑常数 c

计算：11111111111111/222222222222222222/3333333333333333密文可得，

有边界条件 t=0/n=0时，encrypt_nt(0) = 0

猜测，encrypt_nt(x) = x

那么最后就是最复杂的 encrypt_x(n) 

分析边界 n=0 上的条件

n=0: 0 470 68 6 036 24 2 692 80 8 258 46 4 814 02

去除 t 的影响：

n_t=0: 0 357 23 0 357 23 0 ……

可以很容易看出规律是 0 23 357

再分析边界 t=0 上的条件

011388655922299566833

0123456789                            n=

经过分析可得出

当当前组的种类为 0/1/2 时，不同的 encrypt_x(n,type)

0：加 n

1：加 10-n

2：加 10-n

再同理，分析 t=1 t=2 上的条件可得总体为：

0: n

1: 10-n n

2: 10-n n 10-n

最后，合并三个正交方向的 encrypt 函数

注：后面为了让程序更好写，n_t 改成了 0 24 369，然后 t 每次就不用单独计数了

不然计数器挺麻烦的